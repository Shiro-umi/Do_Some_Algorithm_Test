># 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 
>  
>示例 1：  
>输入: "babad"  
>输出: "bab"  
>注意: "aba" 也是一个有效答案。  
>  
>示例 2：  
>输入: "cbbd"  
>输出: "bb"  

看似很简单的一道题，其实..  
为什么说它很简单呢，因为这道题只有一个关键的点，想通了问题就可以比较高效地解决。  
我们来想一下回文的定义：  
**将一个串倒序之后如果与原来的串想通则为回文**  
或者：  
**将一个串以中间位置对折若完全重合则为回文**  
下面看看如下例子：  
```
"abcba"
"abccba"  
```  
通过上面的例子结合上述定义不难发现，符合回文定义的字符串都存在一个性质：  
**回文串的两边各自-1得到的结果也必定是回文**  
也可以理解为：  
**回文串的两边各自+1相同的字符得到的结果也必定是回文**  
看到这里想必思路就明朗了很多。若是暴力遍历的话用脚后跟想一想都知道里面存在着巨量的冗余。  
但是根据上面总结到的性质，当我们找到一个回文的时候，如果它的两边+1字符相同的话，那么当前串就不是最长的回文子串。
  
分析到这个程度，我的脑子里首先浮现出的思路是`递归`。试想一下，如果我们通过一个判别方法`searchPalindrome(L,R)`知道了`s[L:R]`为回文子串，那么我们就可以在这个方法中直接递归调用`searchPalindrome(L-1,R+1)`来判断当前递归主体的字串`s[L,R]`是不是最长回文字串，或者说是判断`s[L-1,R+1]`是不是比`s[L,R]`更长的回文字串。  
```python  
def searchPalindrome(L, R):
    if isPalindrome(s[L:R]):
            searchPalindrome(L-1, R+1)
    else:
        return
```
下面我们还剩下一个需要解决的问题：  
根据上面举例的回文串，不难发现`abcba`和`abccba`都是回文串，也就是说**递归入口**必须加入两种不通结构的回文判别逻辑才能够解决问题。  
那么如何来解决这个问题呢？再来回忆一下回文的第二个定义，是不是也可以解释为**回文串都是中心对称的**，那么从这个角度出发，使用一个函数去表示这个中心，问题就迎刃而解了。当回文串长度为奇数的时候，这个中心应该计算为正中间的那个数。但当长度为偶数的时候，这个中心为  
抽象表示如下：  
```python  
# 抽象表示字串中心的L和R
center = calculate_center(s[L:R])

```
